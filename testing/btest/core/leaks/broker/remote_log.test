# @TEST-SERIALIZE: brokercomm
# @TEST-REQUIRES: grep -q ENABLE_BROKER:BOOL=true $BUILD/CMakeCache.txt
# @TEST-REQUIRES: bro --help 2>&1 | grep -q mem-leaks
# @TEST-GROUP: leak

# @TEST-EXEC: HEAP_CHECK_DUMP_DIRECTORY=. HEAPCHECK=local btest-bg-run recv "bro -m -b ../common.bro ../recv.bro broker_port=$BROKER_PORT >recv.out"
# @TEST-EXEC: HEAP_CHECK_DUMP_DIRECTORY=. HEAPCHECK=local btest-bg-run send "bro -m -b ../common.bro ../send.bro broker_port=$BROKER_PORT >send.out"

# @TEST-EXEC: btest-bg-wait 45
# @TEST-EXEC: btest-diff recv/recv.out
# @TEST-EXEC: btest-diff recv/test.log
# @TEST-EXEC: btest-diff send/send.out
# @TEST-EXEC: btest-diff send/test.log

@TEST-START-FILE common.bro

module Test;

export {
	redef enum Log::ID += { LOG };

	type my_enum: enum { testenum };

	type my_rec: record {
		a: string;
		b: count &optional;
	} &log;

	type Info: record {
		msg: string &log;
		nolog: string &default="no";
		num: count &log;
		inum: int &log;
		dnum: double &log;
		b: bool &log;
		ip: addr &log;
		sn: subnet &log;
		p: port &log;
		t: time &log;
		ti: interval &log;
		en: my_enum &log;
		se: set[string] &log;
		re: my_rec &log;
		ve: vector of string &log;
	};

	global log_test: event(rec: Test::Info);
}

event bro_init() &priority=5
	{
	Broker::enable();
	Log::create_stream(Test::LOG, [$columns=Test::Info, $ev=log_test]);
	}

@TEST-END-FILE

@TEST-START-FILE recv.bro

const broker_port: port &redef;
redef exit_only_after_terminate = T;

event bro_init()
	{
	Broker::subscribe_to_logs("bro/log/");
	Broker::listen(broker_port, "127.0.0.1");
	}

event Test::log_test(rec: Test::Info)
	{
	print "wrote log", rec;

	if ( rec$num == 5 )
		terminate();
	}

@TEST-END-FILE

@TEST-START-FILE send.bro

const broker_port: port &redef;
redef exit_only_after_terminate = T;

event bro_init()
	{
	Broker::enable_remote_logs(Test::LOG);
	Broker::connect("127.0.0.1", broker_port, 1secs);
	}

global n = 0;

# Test both IPv4 and IPv6 addrs, and test all port types.
global ports: vector of port = vector(22/tcp, 53/udp, 8/icmp, 0/unknown);
global addrs: vector of addr = vector(10.20.30.40, [fe80:abcd::1]);
global subnets: vector of subnet = vector(10.2.0.0/16, [fe80::]/64);

# Test some empty objects.
global emptyset: set[string];
global emptyvector: vector of string;

event do_write()
	{
	local logrec: Test::Info = [$msg = "ping", $num = n, $inum = -2,
		$dnum = 3.14, $b = T, $ip = addrs[n%2], $sn = subnets[n%2],
		$p = ports[n%4], $t = double_to_time(1.5), $ti = 1min,
		$en = Test::testenum, $se = set("hi", "hello"),
		$re = [$a="msg", $b=3], $ve = vector("1st", "2nd", "3rd")];

	if ( n == 1 )
		{
		# Test that some empty or uninitialized values can be sent.
		logrec$msg = "";
		logrec$re = [$a="msg"];
		logrec$se = emptyset;
		logrec$ve = emptyvector;
		}

	Log::write(Test::LOG, logrec);
	++n;
	if ( n < 6 )
		event do_write();
	}

event Broker::outgoing_connection_established(peer_address: string,
                                            peer_port: port,
                                            peer_name: string)
	{
	print "Broker::outgoing_connection_established", peer_address, peer_port;
	event do_write();
	}

event Broker::outgoing_connection_broken(peer_address: string,
                                       peer_port: port,
                                       peer_name: string)
	{
	terminate();
	}

@TEST-END-FILE
